{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MonitorInterval = exports.RTTPinger = exports.Monitor = void 0;\n\nconst timers_1 = require(\"timers\");\n\nconst bson_1 = require(\"../bson\");\n\nconst connect_1 = require(\"../cmap/connect\");\n\nconst connection_1 = require(\"../cmap/connection\");\n\nconst constants_1 = require(\"../constants\");\n\nconst error_1 = require(\"../error\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n\nconst utils_1 = require(\"../utils\");\n\nconst common_1 = require(\"./common\");\n\nconst events_1 = require(\"./events\");\n\nconst server_1 = require(\"./server\");\n/** @internal */\n\n\nconst kServer = Symbol('server');\n/** @internal */\n\nconst kMonitorId = Symbol('monitorId');\n/** @internal */\n\nconst kConnection = Symbol('connection');\n/** @internal */\n\nconst kCancellationToken = Symbol('cancellationToken');\n/** @internal */\n\nconst kRTTPinger = Symbol('rttPinger');\n/** @internal */\n\nconst kRoundTripTime = Symbol('roundTripTime');\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = (0, utils_1.makeStateMachine)({\n  [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED],\n  [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]\n});\nconst INVALID_REQUEST_CHECK_STATES = new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);\n\nfunction isInCloseState(monitor) {\n  return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;\n}\n/** @internal */\n\n\nclass Monitor extends mongo_types_1.TypedEventEmitter {\n  constructor(server, options) {\n    var _a, _b, _c;\n\n    super();\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new mongo_types_1.CancellationToken();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = undefined;\n    this.s = {\n      state: common_1.STATE_CLOSED\n    };\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS: (_a = options.connectTimeoutMS) !== null && _a !== void 0 ? _a : 10000,\n      heartbeatFrequencyMS: (_b = options.heartbeatFrequencyMS) !== null && _b !== void 0 ? _b : 10000,\n      minHeartbeatFrequencyMS: (_c = options.minHeartbeatFrequencyMS) !== null && _c !== void 0 ? _c : 500\n    });\n    const cancellationToken = this[kCancellationToken]; // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n\n    const connectOptions = Object.assign({\n      id: '<monitor>',\n      generation: server.s.pool.generation,\n      connectionType: connection_1.Connection,\n      cancellationToken,\n      hostAddress: server.description.hostAddress\n    }, options, // force BSON serialization options\n    {\n      raw: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true\n    }); // ensure no authentication is used for monitoring\n\n    delete connectOptions.credentials;\n\n    if (connectOptions.autoEncrypter) {\n      delete connectOptions.autoEncrypter;\n    }\n\n    this.connectOptions = Object.freeze(connectOptions);\n  }\n\n  get connection() {\n    return this[kConnection];\n  }\n\n  connect() {\n    if (this.s.state !== common_1.STATE_CLOSED) {\n      return;\n    } // start\n\n\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = new MonitorInterval(monitorServer(this), {\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n\n  requestCheck() {\n    var _a;\n\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n\n    (_a = this[kMonitorId]) === null || _a === void 0 ? void 0 : _a.wake();\n  }\n\n  reset() {\n    const topologyVersion = this[kServer].description.topologyVersion;\n\n    if (isInCloseState(this) || topologyVersion == null) {\n      return;\n    }\n\n    stateTransition(this, common_1.STATE_CLOSING);\n    resetMonitorState(this); // restart monitor\n\n    stateTransition(this, STATE_IDLE); // restart monitoring\n\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = new MonitorInterval(monitorServer(this), {\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS\n    });\n  }\n\n  close() {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, common_1.STATE_CLOSING);\n    resetMonitorState(this); // close monitor\n\n    this.emit('close');\n    stateTransition(this, common_1.STATE_CLOSED);\n  }\n\n}\n\nexports.Monitor = Monitor;\n\nfunction resetMonitorState(monitor) {\n  var _a, _b, _c;\n\n  (_a = monitor[kMonitorId]) === null || _a === void 0 ? void 0 : _a.stop();\n  monitor[kMonitorId] = undefined;\n  (_b = monitor[kRTTPinger]) === null || _b === void 0 ? void 0 : _b.close();\n  monitor[kRTTPinger] = undefined;\n  monitor[kCancellationToken].emit('cancel');\n  (_c = monitor[kConnection]) === null || _c === void 0 ? void 0 : _c.destroy({\n    force: true\n  });\n  monitor[kConnection] = undefined;\n}\n\nfunction checkServer(monitor, callback) {\n  let start = (0, utils_1.now)();\n  monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err) {\n    var _a;\n\n    (_a = monitor[kConnection]) === null || _a === void 0 ? void 0 : _a.destroy({\n      force: true\n    });\n    monitor[kConnection] = undefined;\n    monitor.emit(server_1.Server.SERVER_HEARTBEAT_FAILED, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err));\n    const error = !(err instanceof error_1.MongoError) ? new error_1.MongoError(err) : err;\n    error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);\n    monitor.emit('resetServer', error);\n    callback(err);\n  }\n\n  const connection = monitor[kConnection];\n\n  if (connection && !connection.closed) {\n    const {\n      serverApi,\n      helloOk\n    } = connection;\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n    const topologyVersion = monitor[kServer].description.topologyVersion;\n    const isAwaitable = topologyVersion != null;\n    const cmd = {\n      [(serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) || helloOk ? 'hello' : constants_1.LEGACY_HELLO_COMMAND]: true,\n      ...(isAwaitable && topologyVersion ? {\n        maxAwaitTimeMS,\n        topologyVersion: makeTopologyVersion(topologyVersion)\n      } : {})\n    };\n    const options = isAwaitable ? {\n      socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,\n      exhaustAllowed: true\n    } : {\n      socketTimeoutMS: connectTimeoutMS\n    };\n\n    if (isAwaitable && monitor[kRTTPinger] == null) {\n      monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], Object.assign({\n        heartbeatFrequencyMS: monitor.options.heartbeatFrequencyMS\n      }, monitor.connectOptions));\n    }\n\n    connection.command((0, utils_1.ns)('admin.$cmd'), cmd, options, (err, hello) => {\n      var _a;\n\n      if (err) {\n        return failureHandler(err);\n      }\n\n      if (!('isWritablePrimary' in hello)) {\n        // Provide hello-style response document.\n        hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];\n      }\n\n      const rttPinger = monitor[kRTTPinger];\n      const duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : (0, utils_1.calculateDurationInMs)(start);\n      monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello)); // if we are using the streaming protocol then we immediately issue another `started`\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n\n      if (isAwaitable && hello.topologyVersion) {\n        monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));\n        start = (0, utils_1.now)();\n      } else {\n        (_a = monitor[kRTTPinger]) === null || _a === void 0 ? void 0 : _a.close();\n        monitor[kRTTPinger] = undefined;\n        callback(undefined, hello);\n      }\n    });\n    return;\n  } // connecting does an implicit `hello`\n\n\n  (0, connect_1.connect)(monitor.connectOptions, (err, conn) => {\n    if (err) {\n      monitor[kConnection] = undefined;\n      failureHandler(err);\n      return;\n    }\n\n    if (conn) {\n      // Tell the connection that we are using the streaming protocol so that the\n      // connection's message stream will only read the last hello on the buffer.\n      conn.isMonitoringConnection = true;\n\n      if (isInCloseState(monitor)) {\n        conn.destroy({\n          force: true\n        });\n        return;\n      }\n\n      monitor[kConnection] = conn;\n      monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), conn.hello));\n      callback(undefined, conn.hello);\n    }\n  });\n}\n\nfunction monitorServer(monitor) {\n  return callback => {\n    stateTransition(monitor, STATE_MONITORING);\n\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n\n      callback();\n    }\n\n    checkServer(monitor, (err, hello) => {\n      if (err) {\n        // otherwise an error occurred on initial discovery, also bail\n        if (monitor[kServer].description.type === common_1.ServerType.Unknown) {\n          return done();\n        }\n      } // if the check indicates streaming is supported, immediately reschedule monitoring\n\n\n      if (hello && hello.topologyVersion) {\n        (0, timers_1.setTimeout)(() => {\n          var _a;\n\n          if (!isInCloseState(monitor)) {\n            (_a = monitor[kMonitorId]) === null || _a === void 0 ? void 0 : _a.wake();\n          }\n        }, 0);\n      }\n\n      done();\n    });\n  };\n}\n\nfunction makeTopologyVersion(tv) {\n  return {\n    processId: tv.processId,\n    // tests mock counter as just number, but in a real situation counter should always be a Long\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)\n  };\n}\n/** @internal */\n\n\nclass RTTPinger {\n  constructor(cancellationToken, options) {\n    this[kConnection] = undefined;\n    this[kCancellationToken] = cancellationToken;\n    this[kRoundTripTime] = 0;\n    this.closed = false;\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n    this[kMonitorId] = (0, timers_1.setTimeout)(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\n  }\n\n  get roundTripTime() {\n    return this[kRoundTripTime];\n  }\n\n  close() {\n    var _a;\n\n    this.closed = true;\n    (0, timers_1.clearTimeout)(this[kMonitorId]);\n    (_a = this[kConnection]) === null || _a === void 0 ? void 0 : _a.destroy({\n      force: true\n    });\n    this[kConnection] = undefined;\n  }\n\n}\n\nexports.RTTPinger = RTTPinger;\n\nfunction measureRoundTripTime(rttPinger, options) {\n  const start = (0, utils_1.now)();\n  options.cancellationToken = rttPinger[kCancellationToken];\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n\n  if (rttPinger.closed) {\n    return;\n  }\n\n  function measureAndReschedule(conn) {\n    if (rttPinger.closed) {\n      conn === null || conn === void 0 ? void 0 : conn.destroy({\n        force: true\n      });\n      return;\n    }\n\n    if (rttPinger[kConnection] == null) {\n      rttPinger[kConnection] = conn;\n    }\n\n    rttPinger[kRoundTripTime] = (0, utils_1.calculateDurationInMs)(start);\n    rttPinger[kMonitorId] = (0, timers_1.setTimeout)(() => measureRoundTripTime(rttPinger, options), heartbeatFrequencyMS);\n  }\n\n  const connection = rttPinger[kConnection];\n\n  if (connection == null) {\n    (0, connect_1.connect)(options, (err, conn) => {\n      if (err) {\n        rttPinger[kConnection] = undefined;\n        rttPinger[kRoundTripTime] = 0;\n        return;\n      }\n\n      measureAndReschedule(conn);\n    });\n    return;\n  }\n\n  connection.command((0, utils_1.ns)('admin.$cmd'), {\n    [constants_1.LEGACY_HELLO_COMMAND]: 1\n  }, undefined, err => {\n    if (err) {\n      rttPinger[kConnection] = undefined;\n      rttPinger[kRoundTripTime] = 0;\n      return;\n    }\n\n    measureAndReschedule();\n  });\n}\n/**\n * @internal\n */\n\n\nclass MonitorInterval {\n  constructor(fn) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _a, _b;\n\n    this.isExpeditedCheckScheduled = false;\n    this.stopped = false;\n\n    this._executeAndReschedule = () => {\n      this.isExpeditedCheckScheduled = false;\n      this.lastCallTime = this.clock();\n      this.fn(err => {\n        if (err) throw err;\n\n        this._reschedule(this.heartbeatFrequencyMS);\n      });\n    };\n\n    this.fn = fn;\n    this.lastCallTime = 0;\n    this.heartbeatFrequencyMS = (_a = options.heartbeatFrequencyMS) !== null && _a !== void 0 ? _a : 1000;\n    this.minHeartbeatFrequencyMS = (_b = options.minHeartbeatFrequencyMS) !== null && _b !== void 0 ? _b : 500;\n    this.clock = typeof options.clock === 'function' ? options.clock : utils_1.now;\n\n    if (options.immediate) {\n      this._executeAndReschedule();\n    } else {\n      this.lastCallTime = this.clock();\n\n      this._reschedule(undefined);\n    }\n  }\n\n  wake() {\n    const currentTime = this.clock();\n    const nextScheduledCallTime = this.lastCallTime + this.heartbeatFrequencyMS;\n    const timeUntilNextCall = nextScheduledCallTime - currentTime; // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n    // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n\n    if (timeUntilNextCall < 0) {\n      this._executeAndReschedule();\n\n      return;\n    } // debounce multiple calls to wake within the `minInterval`\n\n\n    if (this.isExpeditedCheckScheduled) {\n      return;\n    } // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n\n\n    if (timeUntilNextCall > this.minHeartbeatFrequencyMS) {\n      this._reschedule(this.minHeartbeatFrequencyMS);\n\n      this.isExpeditedCheckScheduled = true;\n    }\n  }\n\n  stop() {\n    this.stopped = true;\n\n    if (this.timerId) {\n      (0, timers_1.clearTimeout)(this.timerId);\n      this.timerId = undefined;\n    }\n\n    this.lastCallTime = 0;\n    this.isExpeditedCheckScheduled = false;\n  }\n\n  toString() {\n    return JSON.stringify(this);\n  }\n\n  toJSON() {\n    return {\n      timerId: this.timerId != null ? 'set' : 'cleared',\n      lastCallTime: this.lastCallTime,\n      isExpeditedCheckScheduled: this.isExpeditedCheckScheduled,\n      stopped: this.stopped,\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS\n    };\n  }\n\n  _reschedule(ms) {\n    if (this.stopped) return;\n\n    if (this.timerId) {\n      (0, timers_1.clearTimeout)(this.timerId);\n    }\n\n    this.timerId = (0, timers_1.setTimeout)(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);\n  }\n\n}\n\nexports.MonitorInterval = MonitorInterval;","map":{"version":3,"mappings":"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","names":["kServer","Symbol","kMonitorId","kConnection","kCancellationToken","kRTTPinger","kRoundTripTime","STATE_IDLE","STATE_MONITORING","stateTransition","common_1","INVALID_REQUEST_CHECK_STATES","Set","isInCloseState","monitor","s","state","Monitor","mongo_types_1","constructor","server","options","undefined","setMaxListeners","Infinity","address","description","Object","freeze","connectTimeoutMS","_a","heartbeatFrequencyMS","_b","minHeartbeatFrequencyMS","_c","cancellationToken","connectOptions","assign","id","generation","pool","connectionType","connection_1","hostAddress","raw","promoteLongs","promoteValues","promoteBuffers","credentials","autoEncrypter","connection","connect","MonitorInterval","monitorServer","immediate","requestCheck","has","wake","reset","topologyVersion","resetMonitorState","close","emit","exports","stop","destroy","force","checkServer","callback","start","server_1","SERVER_HEARTBEAT_STARTED","events_1","failureHandler","err","SERVER_HEARTBEAT_FAILED","error","error_1","addErrorLabel","ResetPool","closed","serverApi","helloOk","maxAwaitTimeMS","isAwaitable","cmd","version","constants_1","makeTopologyVersion","socketTimeoutMS","exhaustAllowed","RTTPinger","command","hello","isWritablePrimary","rttPinger","duration","roundTripTime","SERVER_HEARTBEAT_SUCCEEDED","conn","isMonitoringConnection","done","type","Unknown","tv","processId","counter","bson_1","isLong","fromNumber","measureRoundTripTime","measureAndReschedule","fn","isExpeditedCheckScheduled","lastCallTime","clock","_reschedule","utils_1","_executeAndReschedule","currentTime","nextScheduledCallTime","timeUntilNextCall","stopped","timerId","toString","JSON","stringify","toJSON","ms"],"sources":["/Users/drewl/Projects/mwpTutor/tutor/node_modules/mongodb/src/sdam/monitor.ts"],"sourcesContent":["import { clearTimeout, setTimeout } from 'timers';\n\nimport { Document, Long } from '../bson';\nimport { connect } from '../cmap/connect';\nimport { Connection, ConnectionOptions } from '../cmap/connection';\nimport { LEGACY_HELLO_COMMAND } from '../constants';\nimport { MongoError, MongoErrorLabel } from '../error';\nimport { CancellationToken, TypedEventEmitter } from '../mongo_types';\nimport type { Callback } from '../utils';\nimport { calculateDurationInMs, EventEmitterWithState, makeStateMachine, now, ns } from '../utils';\nimport { ServerType, STATE_CLOSED, STATE_CLOSING } from './common';\nimport {\n  ServerHeartbeatFailedEvent,\n  ServerHeartbeatStartedEvent,\n  ServerHeartbeatSucceededEvent\n} from './events';\nimport { Server } from './server';\nimport type { TopologyVersion } from './server_description';\n\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kMonitorId = Symbol('monitorId');\n/** @internal */\nconst kConnection = Symbol('connection');\n/** @internal */\nconst kCancellationToken = Symbol('cancellationToken');\n/** @internal */\nconst kRTTPinger = Symbol('rttPinger');\n/** @internal */\nconst kRoundTripTime = Symbol('roundTripTime');\n\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\n});\n\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\nfunction isInCloseState(monitor: Monitor) {\n  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;\n}\n\n/** @internal */\nexport interface MonitorPrivate {\n  state: string;\n}\n\n/** @public */\nexport interface MonitorOptions\n  extends Omit<ConnectionOptions, 'id' | 'generation' | 'hostAddress'> {\n  connectTimeoutMS: number;\n  heartbeatFrequencyMS: number;\n  minHeartbeatFrequencyMS: number;\n}\n\n/** @public */\nexport type MonitorEvents = {\n  serverHeartbeatStarted(event: ServerHeartbeatStartedEvent): void;\n  serverHeartbeatSucceeded(event: ServerHeartbeatSucceededEvent): void;\n  serverHeartbeatFailed(event: ServerHeartbeatFailedEvent): void;\n  resetServer(error?: MongoError): void;\n  resetConnectionPool(): void;\n  close(): void;\n} & EventEmitterWithState;\n\n/** @internal */\nexport class Monitor extends TypedEventEmitter<MonitorEvents> {\n  /** @internal */\n  s: MonitorPrivate;\n  address: string;\n  options: Readonly<\n    Pick<MonitorOptions, 'connectTimeoutMS' | 'heartbeatFrequencyMS' | 'minHeartbeatFrequencyMS'>\n  >;\n  connectOptions: ConnectionOptions;\n  [kServer]: Server;\n  [kConnection]?: Connection;\n  [kCancellationToken]: CancellationToken;\n  /** @internal */\n  [kMonitorId]?: MonitorInterval;\n  [kRTTPinger]?: RTTPinger;\n\n  get connection(): Connection | undefined {\n    return this[kConnection];\n  }\n\n  constructor(server: Server, options: MonitorOptions) {\n    super();\n\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new CancellationToken();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = undefined;\n    this.s = {\n      state: STATE_CLOSED\n    };\n\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS: options.connectTimeoutMS ?? 10000,\n      heartbeatFrequencyMS: options.heartbeatFrequencyMS ?? 10000,\n      minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS ?? 500\n    });\n\n    const cancellationToken = this[kCancellationToken];\n    // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n    const connectOptions = Object.assign(\n      {\n        id: '<monitor>' as const,\n        generation: server.s.pool.generation,\n        connectionType: Connection,\n        cancellationToken,\n        hostAddress: server.description.hostAddress\n      },\n      options,\n      // force BSON serialization options\n      {\n        raw: false,\n        promoteLongs: true,\n        promoteValues: true,\n        promoteBuffers: true\n      }\n    );\n\n    // ensure no authentication is used for monitoring\n    delete connectOptions.credentials;\n    if (connectOptions.autoEncrypter) {\n      delete connectOptions.autoEncrypter;\n    }\n\n    this.connectOptions = Object.freeze(connectOptions);\n  }\n\n  connect(): void {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    // start\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = new MonitorInterval(monitorServer(this), {\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n\n  requestCheck(): void {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n\n    this[kMonitorId]?.wake();\n  }\n\n  reset(): void {\n    const topologyVersion = this[kServer].description.topologyVersion;\n    if (isInCloseState(this) || topologyVersion == null) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this);\n\n    // restart monitor\n    stateTransition(this, STATE_IDLE);\n\n    // restart monitoring\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = new MonitorInterval(monitorServer(this), {\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS\n    });\n  }\n\n  close(): void {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this);\n\n    // close monitor\n    this.emit('close');\n    stateTransition(this, STATE_CLOSED);\n  }\n}\n\nfunction resetMonitorState(monitor: Monitor) {\n  monitor[kMonitorId]?.stop();\n  monitor[kMonitorId] = undefined;\n\n  monitor[kRTTPinger]?.close();\n  monitor[kRTTPinger] = undefined;\n\n  monitor[kCancellationToken].emit('cancel');\n\n  monitor[kConnection]?.destroy({ force: true });\n  monitor[kConnection] = undefined;\n}\n\nfunction checkServer(monitor: Monitor, callback: Callback<Document | null>) {\n  let start = now();\n  monitor.emit(Server.SERVER_HEARTBEAT_STARTED, new ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err: Error) {\n    monitor[kConnection]?.destroy({ force: true });\n    monitor[kConnection] = undefined;\n\n    monitor.emit(\n      Server.SERVER_HEARTBEAT_FAILED,\n      new ServerHeartbeatFailedEvent(monitor.address, calculateDurationInMs(start), err)\n    );\n\n    const error = !(err instanceof MongoError) ? new MongoError(err) : err;\n    error.addErrorLabel(MongoErrorLabel.ResetPool);\n\n    monitor.emit('resetServer', error);\n    callback(err);\n  }\n\n  const connection = monitor[kConnection];\n  if (connection && !connection.closed) {\n    const { serverApi, helloOk } = connection;\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n    const topologyVersion = monitor[kServer].description.topologyVersion;\n    const isAwaitable = topologyVersion != null;\n\n    const cmd = {\n      [serverApi?.version || helloOk ? 'hello' : LEGACY_HELLO_COMMAND]: true,\n      ...(isAwaitable && topologyVersion\n        ? { maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) }\n        : {})\n    };\n\n    const options = isAwaitable\n      ? {\n          socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,\n          exhaustAllowed: true\n        }\n      : { socketTimeoutMS: connectTimeoutMS };\n\n    if (isAwaitable && monitor[kRTTPinger] == null) {\n      monitor[kRTTPinger] = new RTTPinger(\n        monitor[kCancellationToken],\n        Object.assign(\n          { heartbeatFrequencyMS: monitor.options.heartbeatFrequencyMS },\n          monitor.connectOptions\n        )\n      );\n    }\n\n    connection.command(ns('admin.$cmd'), cmd, options, (err, hello) => {\n      if (err) {\n        return failureHandler(err);\n      }\n\n      if (!('isWritablePrimary' in hello)) {\n        // Provide hello-style response document.\n        hello.isWritablePrimary = hello[LEGACY_HELLO_COMMAND];\n      }\n\n      const rttPinger = monitor[kRTTPinger];\n      const duration =\n        isAwaitable && rttPinger ? rttPinger.roundTripTime : calculateDurationInMs(start);\n\n      monitor.emit(\n        Server.SERVER_HEARTBEAT_SUCCEEDED,\n        new ServerHeartbeatSucceededEvent(monitor.address, duration, hello)\n      );\n\n      // if we are using the streaming protocol then we immediately issue another `started`\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n      if (isAwaitable && hello.topologyVersion) {\n        monitor.emit(\n          Server.SERVER_HEARTBEAT_STARTED,\n          new ServerHeartbeatStartedEvent(monitor.address)\n        );\n        start = now();\n      } else {\n        monitor[kRTTPinger]?.close();\n        monitor[kRTTPinger] = undefined;\n\n        callback(undefined, hello);\n      }\n    });\n\n    return;\n  }\n\n  // connecting does an implicit `hello`\n  connect(monitor.connectOptions, (err, conn) => {\n    if (err) {\n      monitor[kConnection] = undefined;\n\n      failureHandler(err);\n      return;\n    }\n\n    if (conn) {\n      // Tell the connection that we are using the streaming protocol so that the\n      // connection's message stream will only read the last hello on the buffer.\n      conn.isMonitoringConnection = true;\n\n      if (isInCloseState(monitor)) {\n        conn.destroy({ force: true });\n        return;\n      }\n\n      monitor[kConnection] = conn;\n      monitor.emit(\n        Server.SERVER_HEARTBEAT_SUCCEEDED,\n        new ServerHeartbeatSucceededEvent(monitor.address, calculateDurationInMs(start), conn.hello)\n      );\n\n      callback(undefined, conn.hello);\n    }\n  });\n}\n\nfunction monitorServer(monitor: Monitor) {\n  return (callback: Callback) => {\n    stateTransition(monitor, STATE_MONITORING);\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n\n      callback();\n    }\n\n    checkServer(monitor, (err, hello) => {\n      if (err) {\n        // otherwise an error occurred on initial discovery, also bail\n        if (monitor[kServer].description.type === ServerType.Unknown) {\n          return done();\n        }\n      }\n\n      // if the check indicates streaming is supported, immediately reschedule monitoring\n      if (hello && hello.topologyVersion) {\n        setTimeout(() => {\n          if (!isInCloseState(monitor)) {\n            monitor[kMonitorId]?.wake();\n          }\n        }, 0);\n      }\n\n      done();\n    });\n  };\n}\n\nfunction makeTopologyVersion(tv: TopologyVersion) {\n  return {\n    processId: tv.processId,\n    // tests mock counter as just number, but in a real situation counter should always be a Long\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    counter: Long.isLong(tv.counter) ? tv.counter : Long.fromNumber(tv.counter)\n  };\n}\n\n/** @internal */\nexport interface RTTPingerOptions extends ConnectionOptions {\n  heartbeatFrequencyMS: number;\n}\n\n/** @internal */\nexport class RTTPinger {\n  /** @internal */\n  [kConnection]?: Connection;\n  /** @internal */\n  [kCancellationToken]: CancellationToken;\n  /** @internal */\n  [kRoundTripTime]: number;\n  /** @internal */\n  [kMonitorId]: NodeJS.Timeout;\n  closed: boolean;\n\n  constructor(cancellationToken: CancellationToken, options: RTTPingerOptions) {\n    this[kConnection] = undefined;\n    this[kCancellationToken] = cancellationToken;\n    this[kRoundTripTime] = 0;\n    this.closed = false;\n\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n    this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\n  }\n\n  get roundTripTime(): number {\n    return this[kRoundTripTime];\n  }\n\n  close(): void {\n    this.closed = true;\n    clearTimeout(this[kMonitorId]);\n\n    this[kConnection]?.destroy({ force: true });\n    this[kConnection] = undefined;\n  }\n}\n\nfunction measureRoundTripTime(rttPinger: RTTPinger, options: RTTPingerOptions) {\n  const start = now();\n  options.cancellationToken = rttPinger[kCancellationToken];\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n\n  if (rttPinger.closed) {\n    return;\n  }\n\n  function measureAndReschedule(conn?: Connection) {\n    if (rttPinger.closed) {\n      conn?.destroy({ force: true });\n      return;\n    }\n\n    if (rttPinger[kConnection] == null) {\n      rttPinger[kConnection] = conn;\n    }\n\n    rttPinger[kRoundTripTime] = calculateDurationInMs(start);\n    rttPinger[kMonitorId] = setTimeout(\n      () => measureRoundTripTime(rttPinger, options),\n      heartbeatFrequencyMS\n    );\n  }\n\n  const connection = rttPinger[kConnection];\n  if (connection == null) {\n    connect(options, (err, conn) => {\n      if (err) {\n        rttPinger[kConnection] = undefined;\n        rttPinger[kRoundTripTime] = 0;\n        return;\n      }\n\n      measureAndReschedule(conn);\n    });\n\n    return;\n  }\n\n  connection.command(ns('admin.$cmd'), { [LEGACY_HELLO_COMMAND]: 1 }, undefined, err => {\n    if (err) {\n      rttPinger[kConnection] = undefined;\n      rttPinger[kRoundTripTime] = 0;\n      return;\n    }\n\n    measureAndReschedule();\n  });\n}\n\n/**\n * @internal\n */\nexport interface MonitorIntervalOptions {\n  /** The interval to execute a method on */\n  heartbeatFrequencyMS: number;\n  /** A minimum interval that must elapse before the method is called */\n  minHeartbeatFrequencyMS: number;\n  /** Whether the method should be called immediately when the interval is started  */\n  immediate: boolean;\n\n  /**\n   * Only used for testing unreliable timer environments\n   * @internal\n   */\n  clock: () => number;\n}\n\n/**\n * @internal\n */\nexport class MonitorInterval {\n  fn: (callback: Callback) => void;\n  timerId: NodeJS.Timeout | undefined;\n  lastCallTime: number;\n  isExpeditedCheckScheduled = false;\n  stopped = false;\n\n  heartbeatFrequencyMS: number;\n  minHeartbeatFrequencyMS: number;\n  clock: () => number;\n\n  constructor(fn: (callback: Callback) => void, options: Partial<MonitorIntervalOptions> = {}) {\n    this.fn = fn;\n    this.lastCallTime = 0;\n\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1000;\n    this.minHeartbeatFrequencyMS = options.minHeartbeatFrequencyMS ?? 500;\n    this.clock = typeof options.clock === 'function' ? options.clock : now;\n\n    if (options.immediate) {\n      this._executeAndReschedule();\n    } else {\n      this.lastCallTime = this.clock();\n      this._reschedule(undefined);\n    }\n  }\n\n  wake() {\n    const currentTime = this.clock();\n    const nextScheduledCallTime = this.lastCallTime + this.heartbeatFrequencyMS;\n    const timeUntilNextCall = nextScheduledCallTime - currentTime;\n\n    // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n\n    // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n    if (timeUntilNextCall < 0) {\n      this._executeAndReschedule();\n      return;\n    }\n\n    // debounce multiple calls to wake within the `minInterval`\n    if (this.isExpeditedCheckScheduled) {\n      return;\n    }\n\n    // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n    if (timeUntilNextCall > this.minHeartbeatFrequencyMS) {\n      this._reschedule(this.minHeartbeatFrequencyMS);\n      this.isExpeditedCheckScheduled = true;\n    }\n  }\n\n  stop() {\n    this.stopped = true;\n    if (this.timerId) {\n      clearTimeout(this.timerId);\n      this.timerId = undefined;\n    }\n\n    this.lastCallTime = 0;\n    this.isExpeditedCheckScheduled = false;\n  }\n\n  toString() {\n    return JSON.stringify(this);\n  }\n\n  toJSON() {\n    return {\n      timerId: this.timerId != null ? 'set' : 'cleared',\n      lastCallTime: this.lastCallTime,\n      isExpeditedCheckScheduled: this.isExpeditedCheckScheduled,\n      stopped: this.stopped,\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS\n    };\n  }\n\n  private _reschedule(ms?: number) {\n    if (this.stopped) return;\n    if (this.timerId) {\n      clearTimeout(this.timerId);\n    }\n\n    this.timerId = setTimeout(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);\n  }\n\n  private _executeAndReschedule = () => {\n    this.isExpeditedCheckScheduled = false;\n    this.lastCallTime = this.clock();\n\n    this.fn(err => {\n      if (err) throw err;\n      this._reschedule(this.heartbeatFrequencyMS);\n    });\n  };\n}\n"]},"metadata":{},"sourceType":"script"}